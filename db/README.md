## 			                  MYSQL数据库规范
### 数据库命名规范

* 所有数据库对象名称必须使用小写字母并用下划线分割（因为Mysql在Win下不敏感在Linux下是敏感的）
* 所有数据库对象名称禁止使用mysql保留的关键字（如果使用了，需要使用``进行转换，[关键字地址](https://dev.mysql.com/doc/refman/5.7/en/keywords.html)）
* 数据库对象的命名能够做到见名识义。
* 所有的临时表必须以tmp为前缀并以日期为后缀，备份表必须以bak为前缀并以日期为后缀（数据库清理时好进行筛选）
* 所有存储相同数据的列名和列类型必须一致（名称相同容易识别，类型一致保证索引不会失效）

### 数据库基本设计规范

* 如果没有特殊需求全部使用Innodb存储引擎（5.6以后Innodb为默认的存储引擎，支持事务，行级锁，更好的恢复性，高并发下性能更好）
* 数据库和表的字符集统一使用UTF-8(UTF-8兼容性更好，字符集统一避免乱码，比较转换等问题。Mysql中的UTF-8字符集汉字占用3个字节，	ASCII码占用1个字节)
* 所有的表和字段都需要添加注释（使用comment从句添加表和列的备注，从一开始就维护好数据字典）
* 尽量控制单表数据量的大小，建议控制在500万以下（存储的限制取决于存储设置和文件系统。日志类历史数据归档，业务表进行分库分表。谨慎使用Mysql分区表,虽然物理上表现为多个文件，在逻辑上表现为一个表。多文件存储主要是为了优化IO,但是如果多个文件都存储在一个磁盘上，性能有可能会更低。）
* 尽量做到冷热数据分离，减小表的宽度（减少磁盘IO,保证热数据 的内存缓存命中率，将经常一起使用的列放到一起，减小表关联）
* 禁止在表中建立预留字段（字段预留时很难见名识义也无法确认存储的数据类型，后续对表进行类型修改时会进行锁表，严重影响性能。）
* 禁止在数据库中存储图片，文件等二进制数据（可能会造成数据文件快速膨胀，在文件系统进行随机IO时严重影响性能。使用文件存储服务器进行存储）

### 数据库索引设计规范

* 单表索引数量不超过5个（索引可以提高查询的效率，降低更新，插入的效率。如果同时存在多个可用索引会增加Mysql生成执行计划的时间，降低性能。禁止给表中的每一列都建立独立的索引）
* 每一个Innodb表都要有主键（Innodb是按照主键索引来组织表，不使用频繁更新的列作为主键，不使用多列主键，不使用UUID,MD5,HASH,字符串列作为主键，因为无法保证顺序性，会导致大量的IO操作，降低性能。可以使用Mysql自增id）
* 常见索引列：
  * SELECT 、UPDATE、DELETE语句的WHERE从句的列
  * 包含在ORDER BY、GROUP BY 、DISTINCT中的字段
  * 多表 JOIN 的关联列
* 索引列的顺序
  * 区分度坐高的列放在联合索引的最左侧（例如：主键）
  * 尽量把字段长度小的字段放在联合索引左侧
  * 尽量把使用最频繁的列放在联合索引的左侧
* 避免建立冗余索引和重复索引（例：primary key（id）= index（id） + unique index （id）; index（a,b,c）、index（a,b）、index（a）： 联合索引从左往右使用，故a列冗余）
* 对于频繁使用的查询优先考虑使用覆盖索引（避免Innodb表进行索引的二次查找）
* 不建议使用外键约束（通常情况下，外键约束是为了保证数据的完整性，建议在业务端实现，外键在做校验的时候会影响父表和子表的写操作性能）

### 数据库字段设计规范

* 优先选择符合存储需要的最小的数据类型
  * 将字符串转化为数字类型存储（例：INET_ATON('255.255.255.255')=4294967295）
  * 对于非负整数使用无符号整型进行存储（unsigned Int 范围更大（0 ~ 4294967295））
  * 在Mysql中varchar(N) 中代表的是字符数，而不是字节数，其他数据库不同（使用UTF-8存储汉字Varchar(255)=765个字节）
  * 过大的长度会消耗更多的内存
* 尽量避免使用text，blob 数据类型（在排序的使用只能使用磁盘临时表进行排序等操作，性能很低，而且当BLOB与TEXT的值太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内会采用1~4个自己存储指针，在外部存储区域存储实际值 ）,如果使用的话，建立独立出去
* 避免使用ENUM （按照整型数据的索引值进行存储，如果使用order by 需要转换为字符串，无法使用索引）
* 尽可能的将列定义为NOT NULL （索引NULL 列需要额外的空间存储状态值。在进行比较和计算时都需要进行处理）
* 尽量不要使用字符串存储日期型的数据（无法使用日期函数进行计算和比较，字符串存储的占用空间多）
* TIMESTAMP或DATATIME类型存储时间
* 涉及到金额类的数据，使用decimal 类型（decimal 为精确数据类型，其占用空间由定义的宽度。也可以使用decimal 保存超过bigint存储范围的数据）

### 数据库SQL开发规范

* 建议使用预编译语句进行数据库操作（重复使用执行计划，避免动态sql的sql注入问题）
* 避免数据类型的隐式转换（隐式转换会导致索引失败）
* 充分的利用表上已经存在的索引（避免双%的查询条件。一个SQL只能利用到复合索引中的一列进行范围查询）
* 使用 left join 或者是 not exists 来优化 not in 操作（not in 通常会使索引失效）
* 程序连接不同数据库使用不同的账号，禁止跨库查询（为数据库迁移和分布留出余地，降低业务的耦合度，避免权限过大而产生的安全风险）
* 禁止使用 SELECT * 语句（消耗更多的CPU,IO资源。也无法使用到覆盖索引。减少表结构变更带来的影响）
* 禁止使用不含字段列表的INSERT 语句（减少表结构变更带来的影响）
* 尽量对子查询尽量优化为join操作（子查询返回的结果集无法使用索引，如果子查询返回的数据如果特别大会严重影响效率，而且会产生很多临时表）
* 避免join 过多的表（每join 一个表多占用一部分内存（join_buffer_size）,而且会产生临时表操作，影响查询效率，Mysql 中最多关联61个表）
* 使用 in 代替 or (in可以有效的利用索引)
* 在明显不会有重复值时使用union all 而不是union（union 会把所有数据放到临时表中进行去重操作）

### 数据库操作行为规范

* 大数量批量写操作要分批次进行（大批量操作可能会造成严重的主从延迟，binlog日志为row格式时会产生大量的日志，日志传输和恢复的时间也就越长，避免大事务操作）
* 对大表进行数据结构进行修改时会造成锁表严重影响正常的数据写入 ，建议使用pt-online-schema-change 修改表结构
* 禁止为程序使用的账号赋予super权限（当达到最大连接数限制时，还允许一个有super权限的用户连接，super权限只能留给DBA管理使用）
* 对于程序连接数据库账号，遵循权限最小原则
* 程序使用的账号原则上不准有drop权限